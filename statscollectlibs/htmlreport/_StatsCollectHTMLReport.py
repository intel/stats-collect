# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2022-2023 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Adam Hawley <adam.james.hawley@intel.com>

"""This module provides the API for generating 'stats-collect' HTML reports."""

import logging
from pepclibs.helperlibs.Exceptions import Error
from statscollectlibs.helperlibs import FSHelpers
from statscollectlibs.htmlreport import HTMLReport, _IntroTable
from statscollectlibs.htmlreport.tabs import _CapturedOutputTabBuilder, _SPECjbb2015TabBuilder
from statscollectlibs.rawresultlibs import RORawResult

_LOG = logging.getLogger()

class StatsCollectHTMLReport:
    """
    This class provides the API for generating 'stats-collect' HTML reports.

    'stats-collect' HTML reports consist of generic statistics tabs and specific 'stats-collect'
    tabs. The former tabs are implemented by the 'HTMLReport' class.

    This adds 'stats-collect' specific tabs to the report generated by the 'HTMLReport' class.

    Furthermore, the 'HTMLReport' class is also used by other projects to extend HTML reports with
    other tabs.
    """

    def _copy_logs(self):
        """
        Copy logs from the raw result directory to the output directory.
        """

        copied_paths = {}
        results_dir = self.outdir / "results"

        for res in self.rsts:
            dst_dir = results_dir / f"raw-{res.reportid}"
            src_dir = res.logs_path.relative_to(res.dirpath)
            try:
                dst_dir.mkdir(parents=True, exist_ok=True)

                logs_dst = dst_dir / src_dir
                if not logs_dst.exists():
                    HTMLReport.copy_dir(res.dirpath / src_dir, logs_dst)

            except (OSError, Error) as err:
                _LOG.warning("unable to copy log files to the generated report: %s", err)
            else:
                copied_paths[res.reportid] = logs_dst.relative_to(self.outdir)

        return copied_paths

    def _link_wldata(self):
        """
        If the raw results include the workload data sub-directory, add create symbolic links in the
        output directory pointing to the raw workload data directory.
        """

        copied_paths = {}
        results_dir = self.outdir / "results"

        for res in self.rsts:
            if not res.wldata_path.exists():
                continue
            dst_dir = results_dir / f"raw-{res.reportid}"
            src_dir = res.wldata_path
            try:
                dst_dir.mkdir(parents=True, exist_ok=True)

                wldata_dst = dst_dir / "raw"
                FSHelpers.move_copy_link(src_dir, wldata_dst, action="symlink", exist_ok=True)
            except (OSError, Error) as err:
                _LOG.warning("unable to copy log files to the generated report: %s", err)
            else:
                copied_paths[res.reportid] = wldata_dst.relative_to(self.outdir)

        return copied_paths

    def _generate_intro_table(self, rsts):
        """
        Helper function for 'generate_stc_report()'. Generates an intro table based on results in
        'rsts'.
        """

        intro_tbl = _IntroTable.IntroTable()
        cmd_row = intro_tbl.create_row("Command", "The command run during statistics collection.")
        for res in rsts:
            cmd_row.add_cell(res.reportid, res.info.get("cmd"))

        # Add tool information.
        tinfo_row = intro_tbl.create_row("Data Collection Tool")
        for res in rsts:
            tool_info = f"{res.info['toolname'].capitalize()} version {res.info['toolver']}"
            tinfo_row.add_cell(res.reportid, tool_info)

        # Add run date.
        date_row = intro_tbl.create_row("Collection Date")
        for res in rsts:
            date_row.add_cell(res.reportid, res.info.get("date"))

        # Add duration.
        date_row = intro_tbl.create_row("Duration")
        for res in rsts:
            date_row.add_cell(res.reportid, res.info.get("duration"))

        # Add link to logs.
        log_paths = self._copy_logs()
        log_row = intro_tbl.create_row("Logs")
        for res in rsts:
            if res.reportid in log_paths:
                log_row.add_cell(res.reportid, "Logs", link=log_paths.get(res.reportid))
            else:
                log_row.add_cell(res.reportid, None)

        # Add links to workload data.
        wldata_paths = self._link_wldata()
        if wldata_paths:
            wldata_row = intro_tbl.create_row("Workload data")
            for res in rsts:
                if res.reportid in wldata_paths:
                    wldata_row.add_cell(res.reportid, "Workload data",
                                        link=wldata_paths.get(res.reportid))
                else:
                    wldata_row.add_cell(res.reportid, None)

        return intro_tbl

    def _get_results_tab(self, tabs_dir):
        """Create and return the results tab object."""

        wltypes = {}
        wltypes_set = set()

        for res in self.rsts:
            wltypes[res.reportid] = res.wltype
            wltypes_set.add(res.wltype)

        if len(wltypes_set) > 1:
            msgs = []
            for res in self.rsts:
                msgs.append(f"{res.reportid}: {wltypes[res.reportid]} "
                            f"({RORawResult.SUPPORTED_WORKLOADS[res.wltype]})")
            msg = " * " + "\n * ".join(msgs)
            wltype = "generic"
            _LOG.warning("multiple workload types detected, assuming a generic workload:\n%s", msg)
        else:
            wltype = next(iter(wltypes_set))

        _LOG.info("Workload type: %s (%s)",
                  wltypes[res.reportid], RORawResult.SUPPORTED_WORKLOADS[res.wltype])
        if wltype == "generic":
            tbldr = _CapturedOutputTabBuilder.CapturedOutputTabBuilder(self.rsts, tabs_dir,
                                                                       basedir=self.outdir)
            return tbldr.get_tab()
        if wltype == "specjbb2015":
            tbldr = _SPECjbb2015TabBuilder.SPECjbb2015TabBuilder(self.rsts, tabs_dir,
                                                                 basedir=self.outdir)
            return tbldr.get_tab()

        raise Error(f"BUG: unsupported workload type '{wltype}'")

    def generate(self):
        """Generate a 'stats-collect' report from the results 'rsts' with 'outdir'."""

        HTMLReport.reportids_dedup(self.rsts)
        rep = HTMLReport.HTMLReport(self.outdir, self.logpath)

        results_tab = self._get_results_tab(rep.tabs_dir)
        tabs = [results_tab] if results_tab else None

        intro_tbl = self._generate_intro_table(self.rsts)
        rep.generate_report(tabs=tabs, rsts=self.rsts, intro_tbl=intro_tbl,
                            title="stats-collect report")

    def __init__(self, rsts, outdir, logpath=None):
        """
        Class constructor. The arguments are as follows.
          * rsts - an iterable collection of aw test results objects ('RORawResult') generate the
                   HTML report for.
          * outdir - the output directory to place the HTML report to.
          * logpath - the path to the report generation log file.
        """

        self.rsts = rsts
        self.outdir = outdir
        self.logpath = logpath
