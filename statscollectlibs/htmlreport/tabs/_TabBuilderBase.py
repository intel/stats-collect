# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2022-2024 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Adam Hawley <adam.james.hawley@intel.com>

"""
Provide the base class and common logic for populating a group of statistics tabs.
"""

from __future__ import annotations # Remove when switching to Python 3.10+.

from pathlib import Path
from typing import cast
from pepclibs.helperlibs import Logging
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound
from statscollectlibs.mdc import MDCBase
from statscollectlibs.htmlreport.tabs import _DTabBuilder, _Tabs, TabConfig
from statscollectlibs.rawresultlibs import RORawResult

_LOG = Logging.getLogger(f"stats-collect.{__name__}")

class MDTypedDict(MDCBase.MDTypedDict, total=False):
    """
    The metric definition dictionary for dataframe column metrics. It is same as
    'MDCBase.MDTypedDict', but describes metric in scope, like "System" or "CPU0".

    Attributes:
        colname: Column name the definition dictionary describes.
        colscope: Column scope, for example "System" or "CPU0".
    """

    colname: str
    colscope: str

class TabBuilderBase:
    """
    The base class and common logic for populating a group of statistics tabs.

    For classes with names such as "_XStatsTabBuilder" and the 'Builder' suffix, their purpose is to
    produce a tab containing data from "XStats". These classes do not represent the tab itself but a
    builder which creates those tabs.

    Tab Configurations - tab builder classes use "tab configurations" to determine the content of
    statistics tabs. These configurations are instances of 'TabConfig.DTabConfig' or
    'TabConfig.CTabConfig'.

    The default tab configurations are generated by the 'get_default_tab_cfg()' method. Statistics
    tab builders provide default tab configurations which include data tabs for all available
    metrics.

    The default configurations can be altered by the caller to customize the layout and contents of
    the statistics tab. The 'get_tab()' method can be used to generate a tab based on a custom tab
    configuration.

    This base class requires child classes to implement the following methods:
    1. Optionally, retrieve the default 'TabConfig.DTabConfig' or 'TabConfig.CTabConfig' instance.
       See 'TabConfig' for more information on tab configurations.
       * 'get_default_tab_cfg()'
    2. Generate a '_Tabs.DTabDC' or '_Tabs.CTabDC' instance which represents statistics found in raw
       statistics files. Optionally provide a tab configuration ('DTabConfig' or 'CTabConfig') to
       customize the tab. This can be based on the default configuration retrieved using
       'get_default_tab_cfg()'.
       * 'get_tab()'
    """

    # The name of the statistics represented in the produced tab.
    name: str | None = None
    stname: str | None = None

    def _get_and_check_cpunum(self, rsts: list[RORawResult.RORawResult]) -> int | None:
        """
        Get the measured CPU number from the raw results and check that all of them have the same
        measured CPU number.

        Args:
            rsts: list of raw result objects to get the measured CPU number from.

        Returns:
            The measured CPU number or 'None' if there is no measured CPU number.
        """

        infos: dict[int, list[Path]] = {}

        for res in rsts:
            cpunum = res.info.get("cpunum")
            if cpunum not in infos:
                infos[cpunum] = []

            infos[cpunum].append(res.dirpath)

        if len(infos) == 1:
            return next(iter(infos))

        if len(infos) < 2:
            raise Error("BUG: no raw results")

        msg = ""
        some_cpunum = None

        for cpunum, paths in infos.items():
            if cpunum is None:
                cpustr = "no measured CPU"
            else:
                cpustr = f"CPU{cpunum}:"
                some_cpunum = cpunum

            msg += f"\n  * {cpustr}"
            for path in paths:
                msg += f"\n    * {path}"

        if some_cpunum is not None:
            cpunum = some_cpunum
            cpustr = f"CPU{cpunum}:"

        _LOG.notice("A mix of measured CPU numbers in %s statistics detected:%s", self.stname, msg)
        _LOG.notice("Will use the following for all results: %s", cpustr)

        return cpunum

    def _get_smry_funcs(self, colname: str) -> list[str]:
        """
        Return the list of summary function names to include to the D-tab summary table for
        dataframe column 'colname' (e.g., "max" for the maximum value, etc).

        Args:
            colname: dataframe column name to return the summary funcion names for.

        Returns:
            A summary function names list.
        """

        colinfo = self._mdd[colname]
        unit = colinfo.get("unit")
        if not unit:
            funcs = ["max", "avg", "min", "std"]
        else:
            funcs = ["max", "99.999%", "99.99%", "99.9%", "99%", "med", "avg", "min", "std"]

        return funcs

    def _build_def_dtab_cfg(self, y_metric, x_metric, hover_defs, hist=False, title=None):
        """
        Provide a way to build a default data tab configuration. Return an instance of
        'TabConfig.DTabConfig'. The arguments are as follows.
          * y_metric - the name of the metric which will be plotted on the y-axis of the tab's
                       scatter plot.
          * x_metric - the name of the metric which will be plotted on the x-axis of the tab's
                       scatter plot.
          * hover_defs - a dictionary in the format '{reportid: hov_defs}' where 'hov_defs' is a
                         list of metric definition dictionaries for the metrics which should be
                         included on plots as hover text for the relevant report with id 'reportid'.
          * hist - whether to include a histogram plot for the metric.
          * title - optionally customize the name of the tab. Defaults to 'y_metric'.
        """

        title = title if title is not None else y_metric
        dtab = TabConfig.DTabConfig(title)
        dtab.add_scatter_plot(x_metric, y_metric)
        if hist:
            dtab.add_hist(y_metric)

        smry_funcs = self._get_smry_funcs(y_metric)
        dtab.set_smry_funcs({y_metric: smry_funcs})
        dtab.set_hover_defs(hover_defs)

        return dtab

    def _build_def_ctab_cfg(self, ctab_name, metrics, def_x_metric, smry_funcs, hover_defs):
        """
        Provide a way to build a default container tab configuration. Return an instance of
        'TabConfig.CTabConfig'. The arguments are the same as 'self._build_def_dtab_cfg()' except
        for the following.
          * ctab_name - the name of the container tab.
          * metrics - a list of names of metrics, for which each should have a data tab.
          * def_x_metric - the name of the metric used on the x-axis of plots for all metrics.
        """

        dtabs = []

        for metric in metrics:
            if metric not in self._mdd:
                continue
            dtabs.append(self._build_def_dtab_cfg(metric, def_x_metric, smry_funcs, hover_defs))

        return TabConfig.CTabConfig(ctab_name, dtabs=dtabs)

    def _resolve_metric(self, metric):
        """
        Resolve 'metric' to a metric definition dictionary from 'self._mdd'. If 'metric' is already
        a metric definition dictionary, then do nothing. Else, try to find the relevant definition
        dictionary from 'self._mdd'.
        """

        def _is_mdef(dct):
            """Returns 'True' if 'dct' is a metric definition dictionary. Else, returns 'False'."""

            try:
                # Try and access the required fields for a metric definition dictionary.
                _ = dct["name"]
                _ = dct["title"]
                _ = dct["descr"]
                return True
            except TypeError:
                return False
            except KeyError:
                return False

        if _is_mdef(metric):
            return metric

        if metric not in self._mdd:
            raise Error(f"BUG: unsupported metric '{metric}'")

        return self._mdd[metric]

    def _add_plots(self, dtabconfig, tab):
        """Add plots to 'tab' based on the metrics specified in the configuration 'dtabconfig'."""

        scatter = []
        for xmetric, ymetric in dtabconfig.scatter_plots:
            x_def = self._resolve_metric(xmetric)
            y_def = self._resolve_metric(ymetric)
            scatter.append((x_def, y_def))

        hists = []
        for metric in dtabconfig.hists:
            hists.append(self._resolve_metric(metric))

        chists = []
        for metric in dtabconfig.chists:
            chists.append(self._resolve_metric(metric))

        hover_defs = {}
        if dtabconfig.hover_defs:
            for reportid, metrics in dtabconfig.hover_defs.items():
                hover_defs[reportid] = [self._resolve_metric(metric) for metric in metrics]

        hover_defs = hover_defs if hover_defs else None

        tab.add_plots(plot_axes=scatter, hist=hists, chist=chists, hover_defs=hover_defs)
        return tab

    def _build_dtab(self, outdir, dtabconfig):
        """Build a data tab according to the tab configuration 'dtabconfig'."""

        tab = _DTabBuilder.DTabBuilder(self._dfs, outdir, dtabconfig.name, self._basedir)
        tab = self._add_plots(dtabconfig, tab)
        tab.add_smrytbl(dtabconfig.smry_funcs, self._mdd)
        for alert in dtabconfig.alerts:
            tab.add_alert(alert)

        return tab.get_tab()

    def _build_ctab(self, outdir, ctabconfig):
        """
        Build a container tab according to the tab configuration 'ctabconfig'. If no sub-tabs can be
        generated then raise an 'Error' and if the config provided is empty then return 'None'. The
        arguments are as follows.
          * outdir - path of the directory in which to store the generated tabs.
          * ctabconfig - an instance of 'TabConfig.CTabConfig' which configures the contents of the
                         resultant container tab.
        """

        if not (ctabconfig.ctabs or ctabconfig.dtabs):
            return None

        # Sub-tabs which will be contained by the returned container tab.
        sub_tabs = []

        for dtabconfig in ctabconfig.dtabs:
            try:
                sub_tabs.append(self._build_dtab(outdir, dtabconfig))
            except Error as err:
                _LOG.debug_print_stacktrace()
                _LOG.warning("failed to generate '%s' tab in '%s' tab:\n%s",
                             dtabconfig.name, self.name, err.indent(2))

        for subtab_cfg in ctabconfig.ctabs:
            subdir = Path(outdir) / _DTabBuilder.get_fsname(subtab_cfg.name)
            subtab = self._build_ctab(subdir, subtab_cfg)

            if subtab:
                sub_tabs.append(subtab)

        if sub_tabs:
            return _Tabs.CTabDC(ctabconfig.name, sub_tabs)

        raise Error(f"unable to generate a container tab for {self.name}.")

    def get_default_tab_cfg(self):
        """
        Generate a 'TabConfig.DTabConfig' or 'TabConfig.CTabConfig' instance representing the
        default tab configuration.
        """

        raise NotImplementedError()

    def get_tab(self, tab_cfg=None):
        """
        Return a '_Tabs.DTabDC' or '_Tabs.CTabDC' instance which represents statistics found in raw
        statistic files. The arguments are as follows.
          * tab_cfg - an instance of 'TabConfig.CTabConfig' or 'Tab.DTabConfig'. If provided, the
            tab builder will attempt to build the tab according to the provided configuration.
            Otherwise, by default, the default tab configuration will be used to build the tab.
        """

        if tab_cfg is None:
            return self.get_tab(self.get_default_tab_cfg())

        if isinstance(tab_cfg, TabConfig.CTabConfig):
            return self._build_ctab(self._outdir, tab_cfg)

        if isinstance(tab_cfg, TabConfig.DTabConfig):
            return self._build_dtab(self._outdir, tab_cfg)

        raise Error(f"unknown tab configuration type '{type(tab_cfg)}, please provide "
                    f"'{TabConfig.CTabConfig.__name__}' or '{TabConfig.DTabConfig.__name__}'")

    def _build_mdd(self, mdd: dict[str, MDCBase.MDTypedDict],
                   colnames: list[str]) -> dict[str, MDTypedDict]:
        """
        Build a new metrics definition dictionary that describes all columns in the dataframe. This
        is applicable to dataframes where columns follow the "<scope name>-<metric name>" format.

        Args:
            mdd: The metrics definition dictionary from one of the 'MCDBase' sub-classes. This
                 dictionary should include all the metrics referenced in 'colnames'.
            colnames: the list of column names in the dataframe.

        Returns:
            A new metrics definition dictionary that describes all columns in the dataframe.
        """

        new_mdd: dict[str, MDTypedDict] = {}

        # Build a metrics definition dictionary describing all columns in the dataframe.
        for colname in colnames:
            split = colname.split("-", 1)
            if len(split) == 1:
                colscope = None
                metric = split[0]
            else:
                colscope, metric = split

            md = new_mdd[colname] = cast(MDTypedDict, mdd[metric].copy())
            md["colname"] = colname

            if colscope:
                md["colscope"] = colscope

        return new_mdd

    def __init__(self, dfs, mdd, outdir, basedir=None):
        """
        The class constructor. The arguments are as follows.
          * dfs - a dictionary in the format '{ReportId: pandas.DataFrame}' for each result where
                  the 'pandas.DataFrame' contains that statistics data for that result.
          * mdd - the metrics definition dictionary describing all the metrics which should be
                  included in the output tab.
          * outdir - the output directory in which to create the sub-directory for the container
                     tab.
          * basedir - base directory of the report. All paths should be made relative to this.
                      Defaults to 'outdir'.

        Adding a statistics container tab will create a sub-directory and store tabs inside it.
        These tabs will represent all of the metrics stored in 'stats_file'.
        """

        if self.name is None:
            raise Error(f"BUG: failed to initialise '{type(self).__name__}': 'name' class "
                        f"attribute not populated.")

        if not dfs:
            raise ErrorNotFound(f"not data for '{self.name}'")

        self._dfs = dfs
        self._mdd = {}
        self._outdir = outdir / _DTabBuilder.get_fsname(self.name)
        self._basedir = basedir if basedir else outdir

        # Make sure the MDs from 'mdd' have the "columns" key, which is the dataframe column names.
        # Column names may not be the same as metric names from the "name" key of MDs. Note, MDD
        # keys are the dataframe column names.
        for colname, md in mdd.items():
            if "colname" not in md:
                self._mdd[colname] = md.copy()
                self._mdd[colname]["colname"] = colname
            else:
                self._mdd[colname] = md

        try:
            self._outdir.mkdir(parents=True, exist_ok=True)
        except OSError as err:
            msg = Error(err).indent(2)
            raise Error(f"failed to create directory '{self._outdir}':\n{msg}") from None
