# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2022-2024 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Authors: Adam Hawley <adam.james.hawley@intel.com>

"""
Provide the base class and common logic for populating a group of statistics tabs.
"""

import logging
from pathlib import Path
from pepclibs.helperlibs.Exceptions import Error, ErrorNotFound
from statscollectlibs.mdc import MDCBase
from statscollectlibs.htmlreport.tabs import _DTabBuilder, _Tabs, TabConfig

_LOG = logging.getLogger()

class TabBuilderBase:
    """
    The base class and common logic for populating a group of statistics tabs.

    For classes with names such as "_XStatsTabBuilder" and the 'Builder' suffix, their purpose is to
    produce a tab containing data from "XStats". These classes do not represent the tab itself but a
    builder which creates those tabs.

    Tab Configurations - tab builder classes use "tab configurations" to determine the content of
    statistics tabs. These configurations are instances of 'TabConfig.DTabConfig' or
    'TabConfig.CTabConfig'.

    The default tab configurations are generated by the 'get_default_tab_cfg()' method. Statistics
    tab builders provide default tab configurations which include data tabs for all available
    metrics.

    The default configurations can be altered by the caller to customize the layout and contents of
    the statistics tab. The 'get_tab()' method can be used to generate a tab based on a custom tab
    configuration.

    This base class requires child classes to implement the following methods:
    1. Optionally, retrieve the default 'TabConfig.DTabConfig' or 'TabConfig.CTabConfig' instance.
       See 'TabConfig' for more information on tab configurations.
       * 'get_default_tab_cfg()'
    2. Generate a '_Tabs.DTabDC' or '_Tabs.CTabDC' instance which represents statistics found in raw
       statistics files. Optionally provide a tab configuration ('DTabConfig' or 'CTabConfig') to
       customize the tab. This can be based on the default configuration retrieved using
       'get_default_tab_cfg()'.
       * 'get_tab()'
    """

    # The name of the statistics represented in the produced tab.
    name: str | None = None

    def _build_def_dtab_cfg(self, y_metric, x_metric, smry_funcs, hover_defs, title=None):
        """
        Provide a way to build a default data tab configuration. Return an instance of
        'TabConfig.DTabConfig'. The arguments are as follows.
          * y_metric - the name of the metric which will be plotted on the y-axis of the tab's
                       scatter plot.
          * x_metric - the name of the metric which will be plotted on the x-axis of the tab's
                       scatter plot.
          * smry_funcs - a dictionary in the format '{metric: summary_func}', for example:
                         {Metric1: ["99.999%", "99.99%",...],
                          Metric2: ["max", "min",...]}
                         Note, 'summary_func' is allowed to be 'None', which means that no functions
                         will be applied to the metric, and can be used for metrics that have only
                         on value.
          * hover_defs - a dictionary in the format '{reportid: hov_defs}' where 'hov_defs' is a
                         list of metric definition dictionaries for the metrics which should be
                         included on plots as hover text for the relevant report with id 'reportid'.
          * title - optionally customize the name of the tab. Defaults to 'y_metric'.
        """

        title = title if title is not None else y_metric
        dtab = TabConfig.DTabConfig(title)
        dtab.add_scatter_plot(x_metric, y_metric)
        dtab.add_hist(y_metric)
        dtab.set_smry_funcs({y_metric: smry_funcs[y_metric]})
        dtab.set_hover_defs(hover_defs)

        return dtab

    def _build_def_ctab_cfg(self, ctab_name, metrics, def_x_metric, smry_funcs, hover_defs):
        """
        Provide a way to build a default container tab configuration. Return an instance of
        'TabConfig.CTabConfig'. The arguments are the same as 'self._build_def_dtab_cfg()' except
        for the following.
          * ctab_name - the name of the container tab.
          * metrics - a list of names of metrics, for which each should have a data tab.
          * def_x_metric - the name of the metric used on the x-axis of plots for all metrics.
        """

        dtabs = []

        for metric in metrics:
            if metric not in self._mdd:
                continue
            dtabs.append(self._build_def_dtab_cfg(metric, def_x_metric, smry_funcs, hover_defs))

        return TabConfig.CTabConfig(ctab_name, dtabs=dtabs)

    def _resolve_metric(self, metric):
        """
        Resolve 'metric' to a metric definition dictionary from 'self._mdd'. If 'metric' is already
        a metric definition dictionary, then do nothing. Else, try to find the relevant definition
        dictionary from 'self._mdd'.
        """

        if MDCBase.is_mdef(metric):
            return metric

        if metric not in self._mdd:
            raise Error(f"BUG: unsupported metric '{metric}'")

        return self._mdd[metric]

    def _add_plots(self, dtabconfig, tab):
        """Add plots to 'tab' based on the metrics specified in the configuration 'dtabconfig'."""

        scatter = []
        for xmetric, ymetric in dtabconfig.scatter_plots:
            x_def = self._resolve_metric(xmetric)
            y_def = self._resolve_metric(ymetric)
            scatter.append((x_def, y_def))

        hists = []
        for metric in dtabconfig.hists:
            hists.append(self._resolve_metric(metric))

        chists = []
        for metric in dtabconfig.chists:
            chists.append(self._resolve_metric(metric))

        hover_defs = {}
        if dtabconfig.hover_defs:
            for reportid, metrics in dtabconfig.hover_defs.items():
                hover_defs[reportid] = [self._resolve_metric(metric) for metric in metrics]

        hover_defs = hover_defs if hover_defs else None

        tab.add_plots(plot_axes=scatter, hist=hists, chist=chists, hover_defs=hover_defs)
        return tab

    def _build_dtab(self, outdir, dtabconfig):
        """Build a data tab according to the tab configuration 'dtabconfig'."""

        tab = _DTabBuilder.DTabBuilder(self._dfs, outdir, dtabconfig.name, self._basedir)
        tab = self._add_plots(dtabconfig, tab)
        tab.add_smrytbl(dtabconfig.smry_funcs, self._mdd)
        for alert in dtabconfig.alerts:
            tab.add_alert(alert)

        return tab.get_tab()

    def _build_ctab(self, outdir, ctabconfig):
        """
        Build a container tab according to the tab configuration 'ctabconfig'. If no sub-tabs can be
        generated then raise an 'Error' and if the config provided is empty then return 'None'. The
        arguments are as follows.
          * outdir - path of the directory in which to store the generated tabs.
          * ctabconfig - an instance of 'TabConfig.CTabConfig' which configures the contents of the
                         resultant container tab.
        """

        if not (ctabconfig.ctabs or ctabconfig.dtabs):
            return None

        # Sub-tabs which will be contained by the returned container tab.
        sub_tabs = []

        for dtabconfig in ctabconfig.dtabs:
            try:
                sub_tabs.append(self._build_dtab(outdir, dtabconfig))
            except Error as err:
                _LOG.debug_print_stacktrace()
                _LOG.warning("failed to generate '%s' tab in '%s' tab:\n%s",
                             dtabconfig.name, self.name, err.indent(2))

        for subtab_cfg in ctabconfig.ctabs:
            subdir = Path(outdir) / MDCBase.get_fsname(subtab_cfg.name)
            subtab = self._build_ctab(subdir, subtab_cfg)

            if subtab:
                sub_tabs.append(subtab)

        if sub_tabs:
            return _Tabs.CTabDC(ctabconfig.name, sub_tabs)

        raise Error(f"unable to generate a container tab for {self.name}.")

    def get_default_tab_cfg(self):
        """
        Generate a 'TabConfig.DTabConfig' or 'TabConfig.CTabConfig' instance representing the
        default tab configuration.
        """

        raise NotImplementedError()

    def get_tab(self, tab_cfg=None):
        """
        Return a '_Tabs.DTabDC' or '_Tabs.CTabDC' instance which represents statistics found in raw
        statistic files. The arguments are as follows.
          * tab_cfg - an instance of 'TabConfig.CTabConfig' or 'Tab.DTabConfig'. If provided, the
            tab builder will attempt to build the tab according to the provided configuration.
            Otherwise, by default, the default tab configuration will be used to build the tab.
        """

        if tab_cfg is None:
            return self.get_tab(self.get_default_tab_cfg())

        if isinstance(tab_cfg, TabConfig.CTabConfig):
            return self._build_ctab(self._outdir, tab_cfg)

        if isinstance(tab_cfg, TabConfig.DTabConfig):
            return self._build_dtab(self._outdir, tab_cfg)

        raise Error(f"unknown tab configuration type '{type(tab_cfg)}, please provide "
                    f"'{TabConfig.CTabConfig.__name__}' or '{TabConfig.DTabConfig.__name__}'")

    def __init__(self, dfs, outdir, basedir=None, mdd=None):
        """
        The class constructor. The arguments are as follows.
          * dfs - a dictionary in the format '{ReportId: pandas.DataFrame}' for each result where
            the 'pandas.DataFrame' contains that statistics data for that result.
          * outdir - the output directory in which to create the sub-directory for the container
                     tab.
          * basedir - base directory of the report. All paths should be made relative to this.
                      Defaults to 'outdir'.
          * mdd - the metrics definition dictionary describing all the metrics which should be
                  included in the output tab.

        Adding a statistics container tab will create a sub-directory and store tabs inside it.
        These tabs will represent all of the metrics stored in 'stats_file'.
        """

        if self.name is None:
            raise Error(f"BUG: failed to initialise '{type(self).__name__}': 'name' class "
                        f"attribute not populated.")

        if not dfs:
            raise ErrorNotFound(f"not data for '{self.name}'")

        self._dfs = dfs
        self._outdir = outdir / MDCBase.get_fsname(self.name)
        self._basedir = basedir if basedir else outdir
        self._mdd = mdd

        try:
            self._outdir.mkdir(parents=True, exist_ok=True)
        except OSError as err:
            msg = Error(err).indent(2)
            raise Error(f"failed to create directory '{self._outdir}':\n{msg}") from None
